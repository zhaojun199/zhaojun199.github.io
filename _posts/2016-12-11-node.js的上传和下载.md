---
layout: post
title:  node.js的promise用法
date:   2016-12-11 14:08:00 +0800
categories: 代码
tag: javascript
---

* content
{:toc}

node.js的上传和下载的实现
====================================
包括

* node服务器如何请求远程文件进行下载。
* node作为服务器，其他用户向node服务器请求文件下载。
* node作为服务器，其他用户向node服务器上传文件。

一、向远程服务器请求文件下载
------------------------------------
引入fs模块用于文件操作：`var fs = require('fs');`
引入request模块用于发送post请求：`var request = require('request');`

定义文件的显示名字和实际名字（唯一文件名）：
可以使用类似uuid这种模块来生成唯一文件名。
{% highlight bash %}
var drift = {
			name : messages.duration,	//这里是文件显示的名字
			uniqueName : messages.device_id + new Date().getTime() 	//这里是唯一文件名
		}
{% endhighlight %}

定义文件的保存路径，在该路径下创建一个可写入的文件：
{% highlight bash %}
var path = config.drift_path + drift.uniqueName + '.amr';	//文件的保存路径，这里我是事先知道文件名以.amr为后缀，如果后缀名未知，请自行写逻辑处理 
fs.createWriteStream(path);//在该路径下创建可写文件，如果是把这个下载功能单独封装成一个模块，一定要注意路径问题，这里的路径以使用此方法的js文件路径为准
{% endhighlight %}


{% highlight bash %}
var url = "http://file.api.weixin.qq.com/cgi-bin/media/get?access_token="+val+"&media_id="+messages.media_id;//需要下载的文件路径
//向该路径发送请求，下载文件，以二进制读取，并在获得响应后以二进制写入之前创建的文件中
request({url:url,encoding:'binary'}, function (error, response, body) {
		if (!error && response.statusCode == 200) {
		   	fs.writeFile(path, body, 'binary', function(err) {
              	console.log(err);
              	//在这里保存信息到数据库
            });
		}
	});
{% endhighlight %}

下载成功后可在之前定义的路径中看到文件，之后读者可以自行将文件的路径和文件名对应的保存于数据库中。

resolve:成功后的回调
reject:失败后的回调
then():获取resolve里的返回值后的下一步操作
catch():捕获异常，只要任何一段代码有异常，就会跳到这一步，一般写在最后

{% highlight bash %}
saveSet = (messages,success) => {
    new Promise ((resolve,reject)=>{
            //异步方法
            useDeviceID(messages.openID,(rows)=>{
                resolve(rows);
            })
        拿到第一步的返回值后进行下一步
        }).then((val)=>{
            var params = messages;
            params.deviceID = val;
            delete params.openID;
            //返回第二步的异步回调的返回值给下一个then
            return new Promise((resolve,reject)=>{
                mysql.replaceOne('cocheer_device_basic_info',params,(rows)=>{
                    resolve(rows);
                })
            })
        //拿到第二步的返回值后进行第三步
        }).then((val)=>{
            success(val);
    });
}
{% endhighlight %}

二、中断某一步直接结束
------------------------------------
用return Promise.reject()方法跳出，但得用catch捕获异常， 不然程序会崩溃


{% highlight bash %}

saveSet = (messages,success) => {
    new Promise ((resolve,reject)=>{
            //异步方法
            useDeviceID(messages.openID,(rows)=>{
                resolve(rows);
            })
        拿到第一步的返回值后进行下一步
        }).then((val)=>{
            if(//判断条件){
                //继续第三步
                return new Promise((resolve,reject)=>{
                    mysql.replaceOne('cocheer_device_basic_info',params,(rows)=>{
                        resolve(rows);
                    })
            })
            }else{
                //跳出
                return Promise.reject()；
            }
            
        //拿到第二步的返回值后进行第三步
        }).then((val)=>{
            success(val);
        //跳出到这里
        }).catch((err)=>{
        //这里可以打印错误
    });
}

{% endhighlight %}


三、如何在resolve中返回多个value给then
------------------------------------
因为resolve和then中都只有一个参数可以传递，所以看起来是不能传递多个参数的，但是我们可以借用javascript的参数是不指定数据类型的，所以我们可以把参数val当作数组或者json来传递给下一个then方法，然后用数组或者json来接收参数。

{% highlight bash %}
saveSet = (messages,success) => {
    new Promise ((resolve,reject)=>{
            //异步方法
            useDeviceID(messages.openID,(rows)=>{
                resolve(rows);
            })
        拿到第一步的返回值后进行下一步
        }).then((val)=>{
            var params = messages;
            params.deviceID = val;
            delete params.openID;
            //返回第二步的异步回调的返回值给下一个then
            return new Promise((resolve,reject)=>{
                mysql.replaceOne('cocheer_device_basic_info',params,(rows)=>{
                //这里传递一个数组给下一个方法
                    resolve([rows,params]);
                })
            })
        //拿到第二步的返回值后进行第三步
        }).then((val)=>{
            //这里用数组来接收，并打印
            console.log(val[0]);
            console.log(val[1]);
            success(val);
    });
}
{% endhighlight %}

结束语
====================================
至此，所以编码工作都完成了，其中有些内部的逻辑需要读者自行处理。因为初学node，代码也写得不够完美，node的一些坑也是得自己去踩了才知道，不过node.js擅长处理高并发任务的特点也决定了他未来的地位。
最后，希望大家都能成为大牛。